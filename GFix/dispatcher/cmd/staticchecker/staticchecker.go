package main

import (
	"flag"
	"fmt"
	"github.com/system-pclub/GCatch/GFix/dispatcher/global"
	"github.com/system-pclub/GCatch/GFix/dispatcher/check/C7A"
	"github.com/system-pclub/GCatch/GFix/dispatcher/pointer"
	"github.com/system-pclub/GCatch/GFix/dispatcher/prepare"
	"os"
	"path"
	"strings"
	"sync"
	"time"
)

func tryBuildOnPackagePath(packagePath string) bool {
	var status string
	//gopath := os.Getenv("GOPATH")
	p := packagePath
	for ; len(p) > 5; p, _ = path.Split(p) {
		if p[len(p)-1] == '/' {
			p = p[:len(p)-1]
		}
		println("[DEBUG] trying to compile path: ", p)
		global.Prog, global.Pkgs, status = prepare.Ssa_build_wholeprogam(p, true, true)
		if status == "suc" { //|| status == "type_err"
			println("[DEBUG] compile status: ", status)
			return true
		}
	}
	return false
}

func main() {

	entrance_ptr := flag.String("path", "", "Full path of the target project")
	buggyFilePathPtr := flag.String("buggyfilepath", "", "Full path of the target file")
	include_ptr := flag.String("include", "", "Relative path (what's after /src/) of the target project")
	exclude_ptr := flag.String("exclude", "vendor", "Name of directories that you want to ignore, divided by \":\"")
	max_second_ptr := flag.Int("deadline", 1800000, "After how many seconds this checker is forced to exit")
	makelineno_ptr := flag.Int("makelineno", 0, "The line number of the make channel operation")
	oplineno_ptr := flag.Int("oplineno", 0, "The line number of the send/close/recv channel operation"+
		" that is definitely executed.")
	flag.Parse()

	go func() {
		time.Sleep(time.Duration(*max_second_ptr) * time.Second)
		fmt.Println("The checker has been running for", *max_second_ptr, "seconds. Now force exit")
		os.Exit(1)
	}()

	index_src := strings.Index(*entrance_ptr, "/src/")
	if index_src < 0 {
		fmt.Println("The target project is not in a GOPATH, because its path doesn't contain \"/src/\"")
		os.Exit(2)
	}

	global.Entrance = (*entrance_ptr)[index_src+5:]
	//global.Entrance, _ = path.Split(global.Entrance) //added by dispatcher.
	global.Exclude = prepare.Exclude_path(*exclude_ptr)
	global.Target_GOPATH = (*entrance_ptr)[:index_src]
	global.Absolute_root = (*entrance_ptr)[:index_src] + "/src/"
	global.Absolute_root = strings.ReplaceAll(global.Absolute_root, "//", "/")
	global.Root = *include_ptr
	global.Bug_index = 0 //*bug_index
	global.Bug_index_mu = sync.Mutex{}
	global.Worthy_path = []global.Parent_path{}
	global.GOPATH = os.Getenv("GOPATH")

	if strings.Contains(global.GOPATH, (*entrance_ptr)[:index_src]) == false {
		fmt.Println("The input path doesn't match GOPATH. GOPATH of target project:", (*entrance_ptr)[:index_src], "\tGOPATH:", os.Getenv("GOPATH"))
		os.Exit(3)
	}

	/*C1.Initialize()
	C2.Initialize()
	C3C4.Initialize()
	C4.Initialize()
	C5.Initialize()
	C5A.Initialize()
	C6A.Initialize()*/
	C7A.Initialize()
	/*C8.Initialize()
	C9.Initialize()*/

	dirpath, _ := path.Split(*buggyFilePathPtr)
	if !tryBuildOnPackagePath(dirpath) {
		var status string
		global.Prog, global.Pkgs, status = prepare.Ssa_build_wholeprogam(global.Entrance, true, true)
		if status != "suc" && status != "type_err" {
			println("Cannot build the bug. Exit.")
			return
		}
	}
	process(*buggyFilePathPtr, *makelineno_ptr, *oplineno_ptr)
}

func process(filepath string, makelineno int, oplineno int) {

	//fmt.Println("Process Count:",global.Process_count)
	global.Process_count++

	//prepare all methods, all structures
	global.All_method = nil //prepare.List_all_methods()
	global.All_struct = nil //prepare.List_all_struct(global.Prog)
	global.All_sync_struct = prepare.List_all_sync_struct(global.Prog)
	global.All_sync_global = prepare.List_all_sync_global(global.All_sync_struct, global.Prog)
	global.Defer_map = prepare.Gen_defer_map()
	// run pointer analysis. We have to run the same pointer analysis twice. The second time will use the callgraph generated by the first time
	global.PointerAnalysisResult = pointer.Pointer_build_callgraph()
	global.Call_graph = global.PointerAnalysisResult.CallGraph
	//global.Inst2edge = pointer.BuildSSAToCallgraphEdge(global.Call_graph)
	if global.Call_graph == nil {
		return
	}
	fmt.Println("[DEBUG] finished some global vars. Now Start checker.")
	C7A.Start(filepath, makelineno, oplineno)
}
