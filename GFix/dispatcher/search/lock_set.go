package search

import (
	"fmt"
	"github.com/system-pclub/GCatch/GFix/dispatcher/check/instruction_check"
	"github.com/system-pclub/GCatch/GFix/dispatcher/check/sync_check"
	"github.com/system-pclub/GCatch/GFix/dispatcher/tools/go/ssa"
)

var map1_gen map[ssa.Instruction]string	 //example: "mypkg.mytype.mu_mutex","mypkg.mytype.rwmu_rwmutexR","mypkg.mytype.rwmu_rwmutexW"
var map2_kill map[ssa.Instruction]string
var map3_before map[ssa.Instruction][]string	//example: ["mypkg.mytype.mu_mutex","mypkg.mytype.rwmu_rwmutexR","mypkg.mytype.rwmu_rwmutexW"]
var map4_after map[ssa.Instruction][]string

var todo []*ssa.Instruction


func Alive_mutexs(target_fn ssa.Function) (map[ssa.Instruction][]string) {


	//There are 4 maps for every inst in target_inst.Parent(); map1_gen[inst] lists the mutex/rwmutex generated by this inst;
	//map2_kill[inst] lists the mutex/rwmutex killed by this inst; map3_before[inst] lists mutexes/rwmutexes that haven't been unlocked before this inst
	//map4_after[inst] lists mutexes/rwmutexes that haven't been unlocked after this inst
	map1_gen = make(map[ssa.Instruction]string)
	map2_kill = make(map[ssa.Instruction]string)
	map3_before = make(map[ssa.Instruction][]string)
	map4_after = make(map[ssa.Instruction][]string)
	todo = *new([]*ssa.Instruction)

	//fill map1 and map2
	prepare_map1_map2(target_fn)
	flag_empty_map1 := true
	for _,lock_name := range map1_gen{
		if lock_name != "" {
			flag_empty_map1 = false
			break
		}
	}
	if flag_empty_map1 == true {
		return nil
	}

	//fill map3 and map4, let
	prepare_map3_map4(target_fn)
	ptr_head_inst := find_head_inst(target_fn)

	todo = append(todo,ptr_head_inst)


	for len(todo) > 0 {
		inst := *todo[0]

		var previous_insts []*ssa.Instruction
		previous_insts = calc_previous_insts(inst)
		var before []string
		if len(previous_insts) == 0 { //This is the first time this loop is invoked
			before = []string{}

		} else if len(previous_insts) == 1 {
			before = map4_after[*previous_insts[0]]
		} else {					//Union the map4_after of all previous inst
			before = union_prev_inst(previous_insts)
		}
		map3_before[inst] = before

		gen := map1_gen[inst]
		kill := map2_kill[inst]
		after := calc_after(before,gen,kill)


		todo = delete_todo(todo,inst)
		if string_slice_equal(map4_after[inst],after) == false {
			map4_after[inst] = after
			todo = append_in_order_todo(todo,inst) //The order is: if the following inst is the beginning of a BB, append it to the end of todo_list
			//		if the following inst is not the beginning of a BB, append it to the beginning of todo_list
		}

	}

	return map3_before

}

func union_prev_inst(previous_insts []*ssa.Instruction) []string {
	var result []string
	for _,previous_inst := range previous_insts {
		for _,str := range map4_after[*previous_inst] {
			if is_str_in_slice(str,result) == false && str != "init" { //"init" is the initial value in map4_after, see func prepare_map3_map4()
				result = append(result,str)
			}
		}
	}
	return result
}

func is_str_in_slice(str string, slice []string) bool {
	for _,slice_str := range slice {
		if slice_str == str {
			return true
		}
	}
	return false
}

func append_in_order_todo(todo []*ssa.Instruction, inst ssa.Instruction) []*ssa.Instruction {
	next_insts := calc_next_insts(inst)
	for _,next_inst := range next_insts {
		if is_inst_in_slice(*next_inst,todo) == false {
			todo = append(todo,next_inst)
		}
	}
	return todo
}

func is_inst_in_slice(inst ssa.Instruction, slice []*ssa.Instruction) bool {
	for _,slice_inst := range slice {
		if *slice_inst == inst {
			return true
		}
	}
	return false
}

func calc_next_insts(inst ssa.Instruction) []*ssa.Instruction {
	if is_inst_end_of_fn(inst) { //case1: inst is the end of whole function
		return []*ssa.Instruction{}
	}

	for _,bb := range inst.Parent().Blocks {	//case2: inst is the end of a bb (but not the end of whole function)
		if inst == *last_inst_bb(*bb) {
			var result []*ssa.Instruction
			for _,succ_bb := range bb.Succs {
				result = append(result,first_inst_bb(*succ_bb))
			}
			return result
		}
	}

	for _,bb := range inst.Parent().Blocks{ //case3: inst is not the end of a bb
		for index,_ := range bb.Instrs {
			if inst == bb.Instrs[index] {
				var result []*ssa.Instruction
				result = append(result, &bb.Instrs[index+1])
				return result
			}
		}
	}

	fmt.Println("Error when calculating previous insts for inst:",inst)
	panic(inst)

}

func is_inst_end_of_fn(inst ssa.Instruction) bool {
	fn_parent := *inst.Parent()
	all_bbs := fn_parent.Blocks
	if len(all_bbs) == 0 {
		return false
	}

	for _,bb := range all_bbs {
		if len(bb.Succs) == 0 {
			last_inst := last_inst_bb(*bb)
			if inst == *last_inst {
				return true
			}
		}
	}

	return false
}

func string_slice_equal(slice1 []string, slice2 []string) bool {
	if len(slice1) != len(slice2) {
		return false
	}
	for _,str1 := range slice1 {
		flag_found := false
		for _,str2 := range slice2 {
			if str1 == str2 {
				flag_found = true
			}
		}
		if flag_found == false {
			return false
		}
	}
	return true
}

func delete_todo(todo []*ssa.Instruction, inst ssa.Instruction) []*ssa.Instruction {
	var result []*ssa.Instruction
	for _,todo_inst := range todo {
		if *todo_inst != inst {
			result = append(result,todo_inst)
		}
	}

	return result
}

func calc_after(before []string, gen string, kill string) (after []string) {

	after = before
	//before + gen
	if gen != "" {
		after = add_mutex_to_mutexs(after,gen)

	}

	if kill != "" {
		after = remove_mutex_from_mutexs(after,kill)
	}

	return after

}

func remove_mutex_from_mutexs(target_slice []string, delete string) []string {
	var result []string
	for _,str := range target_slice {
		if str != string(delete) {
			result = append(result,str)
		}
	}

	return result
}

func add_mutex_to_mutexs(target_slice []string, add string) (result []string) {
	for _,str := range target_slice {
		if str == string(add) {
			return target_slice
		}
	}
	result = append(target_slice,string(add))
	return result
}



func calc_previous_insts(inst ssa.Instruction) []*ssa.Instruction {
	if is_inst_head_of_fn(inst) { //case1: inst is the head of whole function
		return []*ssa.Instruction{}
	}

	for _,bb := range inst.Parent().Blocks {	//case2: inst is the head of a bb (but not the head of whole function)
		if inst == bb.Instrs[0] {
			var result []*ssa.Instruction
			for _,pred_bb := range bb.Preds {
				result = append(result,last_inst_bb(*pred_bb))
			}
			return result
		}
	}

	for _,bb := range inst.Parent().Blocks{ //case3: inst is not the head of a bb
		for index,_ := range bb.Instrs {
			if inst == bb.Instrs[index] {
				var result []*ssa.Instruction
				result = append(result, &bb.Instrs[index-1])
				return result
			}
		}
	}

	fmt.Println("Error when calculating previous insts for inst:",inst)
	panic(inst)

}

func last_inst_bb(bb ssa.BasicBlock) *ssa.Instruction {
	insts := bb.Instrs
	if len(insts) == 0 {
		return nil
	}

	last_inst := insts[len(insts) - 1]
	return &last_inst
}

func first_inst_bb(bb ssa.BasicBlock) *ssa.Instruction {
	insts := bb.Instrs
	if len(insts) == 0 {
		return nil
	}

	first_inst := insts[0]
	return &first_inst
}

func is_inst_head_of_fn(inst ssa.Instruction) bool {
	bb := *inst.Parent().Blocks[0]
	return bb.Instrs[0] == inst
}



func prepare_map1_map2(target_fn ssa.Function)  {
	all_bbs := target_fn.Blocks //TODO: is it possible that all_bbs are not complete, for anonymous functions or methods?
	for _,bb := range all_bbs {
		for _,inst := range bb.Instrs{
			//inst_position := (global.Prog.Fset).Position(inst.Pos())
			//line := inst_position.Line
			//if line == 580 {
			//	inst_str := inst.String()
			//	_ = inst_str
			//
			//}

			if instruction_check.Is_defer(inst) {
				var primitive_locked string
				primitive_locked = ""
				map1_gen[inst] = primitive_locked

				var primitive_unlocked string
				primitive_unlocked = ""
				map2_kill[inst] = primitive_unlocked
			} else if sync_check.Is_mutex_lock(inst) || sync_check.Is_rwmutex_lock(inst) || sync_check.Is_rwmutex_rlock(inst) {
				var primitive_locked string
				if sync_check.Is_mutex_lock(inst) {
					primitive_locked = string(Mutex_name(inst) + "_mutex")

				} else if sync_check.Is_rwmutex_lock(inst){
					primitive_locked = string(Mutex_name(inst) + "_rwmutex") // Don't distinguish RLock and Lock.
					// Double locks are not allowed, no matter what kind of lock it is

				} else if sync_check.Is_rwmutex_rlock(inst) {
					primitive_locked = string(Mutex_name(inst) + "_rwmutex")
				}
				map1_gen[inst] = primitive_locked

				var primitive_unlocked string
				primitive_unlocked = ""
				map2_kill[inst] = primitive_unlocked

			} else if sync_check.Is_mutex_unlock(inst) || sync_check.Is_rwmutex_unlock(inst) || sync_check.Is_rwmutex_runlock(inst) {
				var primitive_locked string
				primitive_locked = ""
				map1_gen[inst] = primitive_locked

				var primitive_unlocked string
				if sync_check.Is_mutex_unlock(inst) {
					primitive_unlocked = string(Mutex_name(inst) + "_mutex")

				} else if sync_check.Is_rwmutex_unlock(inst){
					primitive_unlocked = string(Mutex_name(inst) + "_rwmutex")// Don't distinguish RLock and Lock.
					// Double locks are not allowed, no matter what kind of lock it is

				} else if sync_check.Is_rwmutex_runlock(inst) {
					primitive_unlocked = string(Mutex_name(inst) + "_rwmutex")
				}
				map2_kill[inst] = primitive_unlocked

			} else {
				var primitive_locked string
				primitive_locked = ""
				map1_gen[inst] = primitive_locked

				var primitive_unlocked string
				primitive_unlocked = ""
				map2_kill[inst] = primitive_unlocked

			}

		}
	}
}


func prepare_map3_map4(target_fn ssa.Function) {
	all_bbs := target_fn.Blocks
	for _, bb := range all_bbs {
		for _, inst := range bb.Instrs {

			var s []string = []string{}
			map3_before[inst] = s
			var s2 = []string{"init"}
			map4_after[inst] = s2
		}
	}
}

func find_head_inst(target_fn ssa.Function) *ssa.Instruction {
	all_bbs := target_fn.Blocks
	for _, bb := range all_bbs {
		for _, inst := range bb.Instrs {
			return &inst
		}
	}
	fmt.Println("Error: can't find head_inst for target_fn:",target_fn.String())
	return nil
}




