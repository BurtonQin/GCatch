package locker

import (
	"github.com/system-pclub/GCatch/GFix/dispatcher/global"
	"github.com/system-pclub/GCatch/GFix/dispatcher/tools/go/ssa"
)

var map1_gen map[ssa.Instruction]*Lock_op
var map2_kill map[ssa.Instruction]*Unlock_op
var map3_before map[ssa.Instruction][]*Lock_op
var map4_after map[ssa.Instruction][]*Lock_op

var INIT_LOCK = &Lock_op{
	Name: "INIT_LOCK",
}

func Before_map(target_fn *ssa.Function, all_lockers []*Locker, entry_locks []*Lock_op, report_double_lock  func(lock1,lock2 *Lock_op)) map[ssa.Instruction][]*Lock_op {

	//There are 4 maps for every inst in target_inst.Parent(); map1_gen[inst] lists the mutex/rwmutex generated by this inst;
	//map2_kill[inst] lists the mutex/rwmutex killed by this inst; map3_before[inst] lists mutexes/rwmutexes that haven't been unlocked before this inst
	//map4_after[inst] lists mutexes/rwmutexes that haven't been unlocked after this inst
	map1_gen = make(map[ssa.Instruction]*Lock_op)
	map2_kill = make(map[ssa.Instruction]*Unlock_op)
	map3_before = make(map[ssa.Instruction][]*Lock_op)
	map4_after = make(map[ssa.Instruction][]*Lock_op)

	//fill map1 and map2
	prepare_map1_map2(target_fn,all_lockers)
	flag_empty_map1 := true
	for _,lock := range map1_gen{
		if lock != nil {
			flag_empty_map1 = false
			break
		}
	}
	if flag_empty_map1 == true && len(entry_locks) == 0{
		return nil
	}

	//fill map3 and map4, let map4 be filled with {"init"}, to make sure that every inst will be scanned at lease once. See the end of for loop
	prepare_map3_map4(target_fn)
	head_inst := find_head_inst(target_fn)
	if head_inst == nil {
		return nil
	}
	
	todo := []ssa.Instruction{head_inst}

	for len(todo) > 0 {
		inst := todo[0]

		//inst_p := (global.Prog.Fset).Position(inst.Pos())

		// calculate the before set
		var previous_insts []ssa.Instruction
		previous_insts = calc_previous_insts(inst)

		var before []*Lock_op
		if len(previous_insts) == 0 { //This is the first time this loop is invoked
			if len(entry_locks) == 0 {
				before = []*Lock_op{}
			} else {
				before = entry_locks
			}


		} else if len(previous_insts) == 1 {
			before = map4_after[previous_insts[0]]
		} else {					//Union the map4_after of all previous inst
			//before = intersection_prev_inst(previous_insts)
			before = union_prev_inst(previous_insts)
		}
		before = delete_init(before)

		map3_before[inst] = before

		gen := map1_gen[inst]
		kill := map2_kill[inst]
		if len(before) == 0 && gen == nil && kill != nil { // something is wrong: this inst is unlocking a locker that is not locked
			return nil
		}

		after := calc_after(before,gen,kill,report_double_lock)

		todo = delete_todo(todo,inst)
		if lock_slice_equal(map4_after[inst],after) == false {
			map4_after[inst] = after
			todo = append_in_order_todo(todo,inst) //The order is: if the following inst is the beginning of a BB, append it to the end of todo_list
			//		if the following inst is not the beginning of a BB, append it to the beginning of todo_list
		}

	}

	return map3_before

}



type locker_inst_tuple struct {
	lock *Lock_op
	inst ssa.Instruction
}

type unlocker_inst_tuple struct {
	unlock *Unlock_op
	inst ssa.Instruction
}

func prepare_map1_map2(fn *ssa.Function, lockers []*Locker) {
	
	// initialize map1 and map2
	for _,bb := range fn.Blocks {
		for _,inst := range bb.Instrs {
			map1_gen[inst] = nil
			map2_kill[inst] = nil
		}
	}

	//Record all insts that are ".Lock"
	all_locker_inst_tuples := []locker_inst_tuple{}
	for _,locker := range lockers {
		for _,lock := range locker.Locks {
			new_tuple := locker_inst_tuple{
				lock: lock,
				inst:   lock.Inst,
			}
			all_locker_inst_tuples = append(all_locker_inst_tuples,new_tuple)
		}
	}

	//Find an inst matching one in lockers, and update map1_gen
	for _,bb := range fn.Blocks {
		for _,inst := range bb.Instrs {

			//inst_p := (global.Prog.Fset).Position(inst.Pos())

			var matching_tuple *locker_inst_tuple
			for _,t := range all_locker_inst_tuples {
				if t.inst == inst {
					matching_tuple = &t
					break
				}
			}

			if matching_tuple == nil {
				continue
			}

			map1_gen[inst] = matching_tuple.lock
		}
	}

	// Do the same thing for map2_kill
	all_unlocker_inst_tuples := []unlocker_inst_tuple{}
	for _,locker := range lockers {
		for _,unlock := range locker.Unlocks {
			if unlock.Is_defer {
				continue
			}
			new_tuple := unlocker_inst_tuple{
				unlock: unlock,
				inst:   unlock.Inst,
			}
			all_unlocker_inst_tuples = append(all_unlocker_inst_tuples,new_tuple)
		}
	}

	for _,bb := range fn.Blocks {
		for _,inst := range bb.Instrs {

			matching_tuple := unlocker_inst_tuple{nil,nil}
			for _,t := range all_unlocker_inst_tuples {
				if t.inst == inst {
					matching_tuple = t
				}
			}
			if matching_tuple.inst == nil {
				continue
			}

			map2_kill[inst] = matching_tuple.unlock
		}
	}
}

// initializing map3 and map4, put a INIT_LOCK in there results, to mark that this is their initial status
func prepare_map3_map4(fn *ssa.Function) {
	
	for _, bb := range fn.Blocks {
		for _, inst := range bb.Instrs {
			map3_before[inst] = []*Lock_op{INIT_LOCK}
			map4_after[inst] = []*Lock_op{INIT_LOCK}
		}
	}
}

func find_head_inst(target_fn *ssa.Function) ssa.Instruction {
	for _, bb := range target_fn.Blocks {
		for _, inst := range bb.Instrs {
			return inst
		}
	}
	return nil
}

func calc_previous_insts(inst ssa.Instruction) []ssa.Instruction {
	if is_inst_head_of_fn(inst) { //case1: inst is the head of whole function
		return []ssa.Instruction{}
	}

	bb := inst.Block()
	if inst == bb.Instrs[0] { //case2: inst is the head of a bb (but not the head of whole function)
		var result []ssa.Instruction
		for _, pred_bb := range bb.Preds {
			result = append(result, last_inst_bb(pred_bb))
		}
		return result
	}

	//case3: inst is not the head of a bb
	for index,_ := range bb.Instrs {
		if inst == bb.Instrs[index] {
			var result []ssa.Instruction
			result = append(result, bb.Instrs[index-1])
			return result
		}
	}
	
	return []ssa.Instruction{}

}

func is_inst_head_of_fn(inst ssa.Instruction) bool {
	bb := *inst.Parent().Blocks[0]
	return bb.Instrs[0] == inst
}

func last_inst_bb(bb *ssa.BasicBlock) ssa.Instruction {
	insts := bb.Instrs
	if len(insts) == 0 {
		return nil
	}

	last_inst := insts[len(insts) - 1]
	return last_inst
}

func union_prev_inst(previous_insts []ssa.Instruction) []*Lock_op {
	var result []*Lock_op
	for _,previous_inst := range previous_insts {
		for _,lock := range map4_after[previous_inst] {
			if is_lock_in_slice(lock,result) == false && lock != INIT_LOCK { //"init" is the initial value in map4_after, see func prepare_map3_map4()
				result = append(result,lock)
			}
		}
	}
	return result
}

func delete_init(slice []*Lock_op) (result []*Lock_op) {
	for _,lock := range slice {
		if lock != INIT_LOCK {
			result = append(result,lock)
		}
	}
	return
}

func calc_after(before []*Lock_op, gen *Lock_op, kill *Unlock_op, report_double_lock  func(lock1,lock2 *Lock_op)) []*Lock_op {

	var after []*Lock_op
	after = before
	//before + gen
	if gen != nil {
		after = add_lock_to_locks(after,gen,report_double_lock)
	}

	if kill != nil {
		after = remove_lock_from_locks_of_given_unlock(after,kill)
	}

	return after

}

func add_lock_to_locks(target_slice []*Lock_op, add *Lock_op, report_double_lock func(lock1,lock2 *Lock_op) ) []*Lock_op {
	for _,lock := range target_slice {
		if report_double_lock != nil {
			if lock.Parent == add.Parent {
				if global.C5A_kill_FP_1 { //C5A_kill_FP_1: only report a Double-Lock bug when the two locks are different
					if add != lock {
						report_double_lock(lock,add)
						return target_slice
					}
				} else {
					report_double_lock(lock,add)
					return target_slice
				}
			}
		}

		if lock == add {
			return target_slice
		}
	}
	result := append(target_slice,add)
	return result
}

func remove_lock_from_locks_of_given_unlock(target_slice []*Lock_op, delete *Unlock_op) []*Lock_op {
	result := []*Lock_op{}
	for _,lock := range target_slice {
		if lock.Parent != delete.Parent {
			result = append(result,lock)
		}
	}

	return result
}

func delete_todo(todo []ssa.Instruction, inst ssa.Instruction) (result []ssa.Instruction) {

	for _,todo_inst := range todo {
		if todo_inst != inst {
			result = append(result,todo_inst)
		}
	}

	return result
}

func lock_slice_equal(slice1 []*Lock_op, slice2 []*Lock_op) bool {
	if len(slice1) != len(slice2) {
		return false
	}
	for _,locker1 := range slice1 {
		flag_found := false
		for _,locker2 := range slice2 {
			if locker1 == locker2 {
				flag_found = true
			}
		}
		if flag_found == false {
			return false
		}
	}
	return true
}

func append_in_order_todo(todo []ssa.Instruction, inst ssa.Instruction) (result []ssa.Instruction) {
	//if the next_inst is the head of a BB, append it to the end of todo_list
	//if the next_inst is not the head of a BB, append it to the beginning of todo_list

	next_insts := calc_next_insts(inst)
	head_of_bb_insts := []ssa.Instruction{}
	not_head_of_bb_insts := []ssa.Instruction{}
	for _,next_inst := range next_insts {
		if is_inst_in_slice(next_inst,todo) == true {
			continue
		}
		if bb := (next_inst).Block(); bb.Instrs[0] == next_inst { //next_inst is the head of a bb
			head_of_bb_insts = append(head_of_bb_insts,next_inst)
		} else {
			not_head_of_bb_insts = append(not_head_of_bb_insts,next_inst)
		}
	}

	for _,not_head_inst := range not_head_of_bb_insts {
		result = append(result,not_head_inst)
	}
	for _,old_inst := range todo {
		result = append(result,old_inst)
	}
	for _,head_inst := range head_of_bb_insts {
		result = append(result,head_inst)
	}

	return
}

func is_inst_in_slice(target ssa.Instruction, slice []ssa.Instruction) bool {
	for _,inst := range slice {
		if inst == target {
			return true
		}
	}
	return false
}

func calc_next_insts(inst ssa.Instruction) []ssa.Instruction {
	if Is_inst_end_of_fn(inst) { //case1: inst is the end of whole function
		return []ssa.Instruction{}
	}

	for _,bb := range inst.Parent().Blocks {	//case2: inst is the end of a bb (but not the end of whole function)
		if inst == last_inst_bb(bb) {
			var result []ssa.Instruction
			for _,succ_bb := range bb.Succs {
				result = append(result,first_inst_bb(succ_bb))
			}
			return result
		}
	}

	for _,bb := range inst.Parent().Blocks{ //case3: inst is not the end of a bb
		for index,_ := range bb.Instrs {
			if inst == bb.Instrs[index] {
				var result []ssa.Instruction
				result = append(result, bb.Instrs[index+1])
				return result
			}
		}
	}

	return nil
}

func Is_inst_end_of_fn(inst ssa.Instruction) bool {
	fn_parent := inst.Parent()
	all_bbs := fn_parent.Blocks
	if len(all_bbs) == 0 {
		return false
	}

	for _,bb := range all_bbs {
		if len(bb.Succs) == 0 {
			last_inst := last_inst_bb(bb)
			if inst == last_inst {
				return true
			}
		}
	}

	return false
}

func first_inst_bb(bb *ssa.BasicBlock) ssa.Instruction {
	insts := bb.Instrs
	if len(insts) == 0 {
		return nil
	}

	first_inst := insts[0]
	return first_inst
}

func is_l_i_tuple_in_slice(target locker_inst_tuple,slice []locker_inst_tuple) bool {
	for _,t := range slice {
		if t == target {
			return true
		}
	}
	return false
}

func is_lock_in_slice(target *Lock_op,slice []*Lock_op) bool {
	for _,locker := range slice {
		if locker == target {
			return true
		}
	}
	return false
}

